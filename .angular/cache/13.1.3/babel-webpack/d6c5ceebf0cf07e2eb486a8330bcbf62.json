{"ast":null,"code":"import { __decorate, __param } from 'tslib';\nimport { ElementRef, Inject, PLATFORM_ID, Injectable, Renderer2, Input, Directive, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { ReplaySubject, throwError } from 'rxjs';\n/** Default values for Component Input */\n\nimport * as ɵngcc0 from '@angular/core';\nconst DEFAULTS = {\n  target: null,\n  action: 'click',\n  duration: 650,\n  easing: 'easeInOutQuad',\n  offset: 0,\n  offsetMap: new Map()\n};\n\nconst ɵ0 = time => {\n  return time * time;\n},\n      ɵ1 = time => {\n  return time * (2 - time);\n},\n      ɵ2 = time => {\n  return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time;\n},\n      ɵ3 = time => {\n  return time * time * time;\n},\n      ɵ4 = time => {\n  return --time * time * time + 1;\n},\n      ɵ5 = time => {\n  return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;\n},\n      ɵ6 = time => {\n  return time * time * time * time;\n},\n      ɵ7 = time => {\n  return 1 - --time * time * time * time;\n},\n      ɵ8 = time => {\n  return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * --time * time * time * time;\n},\n      ɵ9 = time => {\n  return time * time * time * time * time;\n},\n      ɵ10 = time => {\n  return 1 + --time * time * time * time * time;\n},\n      ɵ11 = time => {\n  return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * --time * time * time * time * time;\n},\n      ɵ12 = time => {\n  return Math.pow(2, -10 * time) * Math.sin((time - 1 / 4) * (2 * Math.PI) / 1) + 1;\n};\n/** Easing Colleciton */\n\n\nconst EASING = {\n  easeInQuad: ɵ0,\n  easeOutQuad: ɵ1,\n  easeInOutQuad: ɵ2,\n  easeInCubic: ɵ3,\n  easeOutCubic: ɵ4,\n  easeInOutCubic: ɵ5,\n  easeInQuart: ɵ6,\n  easeOutQuart: ɵ7,\n  easeInOutQuart: ɵ8,\n  easeInQuint: ɵ9,\n  easeOutQuint: ɵ10,\n  easeInOutQuint: ɵ11,\n  easeOutElastic: ɵ12\n};\n/**\n * Set of allowed events as triggers\n * for the Animation to start.\n */\n\nconst EVENTS = ['click', 'mouseenter', 'mouseover', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'wheel', 'mouseleave', 'mouseout'];\n/**\n * Strip hash (#) from value.\n *\n * @param value \t\t\t\tThe given string value\n * @returns \t\t\t\t\tThe stripped string value\n */\n\nfunction stripHash(value) {\n  return value.substring(0, 1) === '#' ? value.substring(1) : value;\n}\n/**\n * Test if a given value is a string.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns \t\t\t\t\t\tWhether the given value is a string\n */\n\n\nfunction isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n/**\n * Test if a given Element is the Window.\n *\n * @param container \t\t\t\tThe given Element\n * @returns \t\t\t\t\t\tWhether the given Element is Window\n */\n\n\nfunction isWindow(container) {\n  return container === window;\n}\n/**\n * Test if a given value is of type ElementRef.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns               Whether the given value is a number\n */\n\n\nfunction isElementRef(value) {\n  return value instanceof ElementRef;\n}\n/**\n * Whether or not the given value is a Native Element.\n *\n * @param value           The given value\n * @returns               Whether or not the value is a Native Element\n */\n\n\nfunction isNativeElement(value) {\n  return value instanceof HTMLElement;\n}\n/**\n * Test if a given value is type number.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns \t\t\t\t\t\tWhether the given value is a number\n */\n\n\nfunction isNumber(value) {\n  return !isNaN(parseFloat(value)) && isFinite(value);\n}\n/** Scroll To Animation */\n\n\nclass ScrollToAnimation {\n  /**\n   * Class Constructor.\n   *\n   * @param container            The Container\n   * @param listenerTarget       The Element that listens for DOM Events\n   * @param isWindow             Whether or not the listener is the Window\n   * @param to                   Position to scroll to\n   * @param options              Additional options for scrolling\n   * @param isBrowser            Whether or not execution runs in the browser\n   *                              (as opposed to the server)\n   */\n  constructor(container, listenerTarget, isWindow, to, options, isBrowser) {\n    this.container = container;\n    this.listenerTarget = listenerTarget;\n    this.isWindow = isWindow;\n    this.to = to;\n    this.options = options;\n    this.isBrowser = isBrowser;\n    /** Recursively loop over the Scroll Animation */\n\n    this.loop = () => {\n      this.timeLapsed += this.tick;\n      this.percentage = this.timeLapsed / this.options.duration;\n      this.percentage = this.percentage > 1 ? 1 : this.percentage; // Position Update\n\n      this.position = this.startPosition + (this.startPosition - this.to <= 0 ? 1 : -1) * this.distance * EASING[this.options.easing](this.percentage);\n\n      if (this.lastPosition !== null && this.position === this.lastPosition) {\n        this.stop();\n      } else {\n        this.source$.next(this.position);\n        this.isWindow ? this.listenerTarget.scrollTo(0, Math.floor(this.position)) : this.container.scrollTop = Math.floor(this.position);\n        this.lastPosition = this.position;\n      }\n    };\n\n    this.tick = 16;\n    this.interval = null;\n    this.lastPosition = null;\n    this.timeLapsed = 0;\n    this.windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n\n    if (!this.container) {\n      this.startPosition = this.windowScrollTop;\n    } else {\n      this.startPosition = this.isWindow ? this.windowScrollTop : this.container.scrollTop;\n    } // Correction for Starting Position of nested HTML Elements\n\n\n    if (this.container && !this.isWindow) {\n      this.to = this.to - this.container.getBoundingClientRect().top + this.startPosition;\n    } // Set Distance\n\n\n    const directionalDistance = this.startPosition - this.to;\n    this.distance = this.container ? Math.abs(this.startPosition - this.to) : this.to;\n    this.mappedOffset = this.options.offset; // Set offset from Offset Map\n\n    if (this.isBrowser) {\n      this.options.offsetMap.forEach((value, key) => this.mappedOffset = window.innerWidth > key ? value : this.mappedOffset);\n    }\n\n    this.distance += this.mappedOffset * (directionalDistance <= 0 ? 1 : -1);\n    this.source$ = new ReplaySubject();\n  }\n  /**\n   * Start the new Scroll Animation.\n   *\n   * @returns         Observable containing a number\n   */\n\n\n  start() {\n    clearInterval(this.interval);\n    this.interval = setInterval(this.loop, this.tick);\n    return this.source$.asObservable();\n  }\n  /**\n   * Stop the current Scroll Animation Loop.\n   *\n   * @param force          Force to stop the Animation Loop\n   * @returns               Void\n   */\n\n\n  stop() {\n    clearInterval(this.interval);\n    this.interval = null;\n    this.source$.complete();\n  }\n\n}\n/**\n * The Scroll To Service handles starting, interrupting\n * and ending the actual Scroll Animation. It provides\n * some utilities to find the proper HTML Element on a\n * given page to setup Event Listeners and calculate\n * distances for the Animation.\n */\n\n\nlet ScrollToService = /*#__PURE__*/(() => {\n  let ScrollToService = class ScrollToService {\n    /**\n     * Construct and setup required paratemeters.\n     *\n     * @param document         A Reference to the Document\n     * @param platformId       Angular Platform ID\n     */\n    constructor(document, platformId) {\n      this.document = document;\n      this.platformId = platformId;\n      this.interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];\n    }\n    /**\n     * Target an Element to scroll to. Notice that the `TimeOut` decorator\n     * ensures the executing to take place in the next Angular lifecycle.\n     * This allows for scrolling to elements that are e.g. initially hidden\n     * by means of `*ngIf`, but ought to be scrolled to eventually.\n     *\n     * @todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:\n     *  - https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481\n     *\n     * @param options         Configuration Object\n     * @returns               Observable\n     */\n\n\n    scrollTo(options) {\n      if (!isPlatformBrowser(this.platformId)) {\n        return new ReplaySubject().asObservable();\n      }\n\n      return this.start(options);\n    }\n    /**\n     * Start a new Animation.\n     *\n     * @todo Emit proper events from subscription\n     *\n     * @param options         Configuration Object\n     * @returns               Observable\n     */\n\n\n    start(options) {\n      // Merge config with default values\n      const mergedConfigOptions = Object.assign(Object.assign({}, DEFAULTS), options);\n\n      if (this.animation) {\n        this.animation.stop();\n      }\n\n      const targetNode = this.getNode(mergedConfigOptions.target);\n\n      if (mergedConfigOptions.target && !targetNode) {\n        return throwError('Unable to find Target Element');\n      }\n\n      const container = this.getContainer(mergedConfigOptions, targetNode);\n\n      if (mergedConfigOptions.container && !container) {\n        return throwError('Unable to find Container Element');\n      }\n\n      const listenerTarget = this.getListenerTarget(container) || window;\n      let to = container ? container.getBoundingClientRect().top : 0;\n\n      if (targetNode) {\n        to = isWindow(listenerTarget) ? window.scrollY + targetNode.getBoundingClientRect().top : targetNode.getBoundingClientRect().top;\n      } // Create Animation\n\n\n      this.animation = new ScrollToAnimation(container, listenerTarget, isWindow(listenerTarget), to, mergedConfigOptions, isPlatformBrowser(this.platformId));\n\n      const onInterrupt = () => this.animation.stop();\n\n      this.addInterruptiveEventListeners(listenerTarget, onInterrupt); // Start Animation\n\n      const animation$ = this.animation.start();\n      this.subscribeToAnimation(animation$, listenerTarget, onInterrupt);\n      return animation$;\n    }\n    /**\n     * Subscribe to the events emitted from the Scrolling\n     * Animation. Events might be used for e.g. unsubscribing\n     * once finished.\n     *\n     * @param animation$              The Animation Observable\n     * @param listenerTarget          The Listener Target for events\n     * @param onInterrupt             The handler for Interruptive Events\n     * @returns                       Void\n     */\n\n\n    subscribeToAnimation(animation$, listenerTarget, onInterrupt) {\n      const subscription = animation$.subscribe(() => {}, () => {}, () => {\n        this.removeInterruptiveEventListeners(this.interruptiveEvents, listenerTarget, onInterrupt);\n        subscription.unsubscribe();\n      });\n    }\n    /**\n     * Get the container HTML Element in which\n     * the scrolling should happen.\n     *\n     * @param options         The Merged Configuration Object\n     * @param targetNode    the targeted HTMLElement\n     */\n\n\n    getContainer(options, targetNode) {\n      let container = null;\n\n      if (options.container) {\n        container = this.getNode(options.container, true);\n      } else if (targetNode) {\n        container = this.getFirstScrollableParent(targetNode);\n      }\n\n      return container;\n    }\n    /**\n     * Add listeners for the Animation Interruptive Events\n     * to the Listener Target.\n     *\n     * @param events            List of events to listen to\n     * @param listenerTarget    Target to attach the listener on\n     * @param handler           Handler for when the listener fires\n     * @returns                 Void\n     */\n\n\n    addInterruptiveEventListeners(listenerTarget, handler) {\n      if (!listenerTarget) {\n        listenerTarget = window;\n      }\n\n      this.interruptiveEvents.forEach(event => listenerTarget.addEventListener(event, handler, this.supportPassive() ? {\n        passive: true\n      } : false));\n    }\n    /**\n     * Feature-detect support for passive event listeners.\n     *\n     * @returns       Whether or not passive event listeners are supported\n     */\n\n\n    supportPassive() {\n      let supportsPassive = false;\n\n      try {\n        const opts = Object.defineProperty({}, 'passive', {\n          get: () => {\n            supportsPassive = true;\n          }\n        });\n        window.addEventListener('testPassive', null, opts);\n        window.removeEventListener('testPassive', null, opts);\n      } catch (e) {}\n\n      return supportsPassive;\n    }\n    /**\n     * Remove listeners for the Animation Interrupt Event from\n     * the Listener Target. Specifying the correct handler prevents\n     * memory leaks and makes the allocated memory available for\n     * Garbage Collection.\n     *\n     * @param events            List of Interruptive Events to remove\n     * @param listenerTarget    Target to attach the listener on\n     * @param handler           Handler for when the listener fires\n     * @returns                 Void\n     */\n\n\n    removeInterruptiveEventListeners(events, listenerTarget, handler) {\n      if (!listenerTarget) {\n        listenerTarget = window;\n      }\n\n      events.forEach(event => listenerTarget.removeEventListener(event, handler));\n    }\n    /**\n     * Find the first scrollable parent Node of a given\n     * Element. The DOM Tree gets searched upwards\n     * to find this first scrollable parent. Parents might\n     * be ignored by CSS styles applied to the HTML Element.\n     *\n     * @param nativeElement     The Element to search the DOM Tree upwards from\n     * @returns                 The first scrollable parent HTML Element\n     */\n\n\n    getFirstScrollableParent(nativeElement) {\n      let style = window.getComputedStyle(nativeElement);\n      const overflowRegex = /(auto|scroll|overlay)/;\n\n      if (style.position === 'fixed') {\n        return null;\n      }\n\n      let parent = nativeElement;\n\n      while (parent.parentElement) {\n        parent = parent.parentElement;\n        style = window.getComputedStyle(parent);\n\n        if (style.position === 'absolute' || style.overflow === 'hidden' || style.overflowY === 'hidden') {\n          continue;\n        }\n\n        if (overflowRegex.test(style.overflow + style.overflowY) || parent.tagName === 'BODY') {\n          return parent;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Get the Target Node to scroll to.\n     *\n     * @param id              The given ID of the node, either a string or\n     *                        an element reference\n     * @param allowBodyTag    Indicate whether or not the Document Body is\n     *                        considered a valid Target Node\n     * @returns               The Target Node to scroll to\n     */\n\n\n    getNode(id, allowBodyTag = false) {\n      let targetNode;\n\n      if (isString(id)) {\n        if (allowBodyTag && (id === 'body' || id === 'BODY')) {\n          targetNode = this.document.body;\n        } else {\n          targetNode = this.document.getElementById(stripHash(id));\n        }\n      } else if (isNumber(id)) {\n        targetNode = this.document.getElementById(String(id));\n      } else if (isElementRef(id)) {\n        targetNode = id.nativeElement;\n      } else if (isNativeElement(id)) {\n        targetNode = id;\n      }\n\n      return targetNode;\n    }\n    /**\n     * Retrieve the Listener target. This Listener Target is used\n     * to attach Event Listeners on. In case of the target being\n     * the Document Body, we need the actual `window` to listen\n     * for events.\n     *\n     * @param container           The HTML Container element\n     * @returns                   The Listener Target to attach events on\n     */\n\n\n    getListenerTarget(container) {\n      if (!container) {\n        return null;\n      }\n\n      return this.isDocumentBody(container) ? window : container;\n    }\n    /**\n     * Test if a given HTML Element is the Document Body.\n     *\n     * @param element             The given HTML Element\n     * @returns                   Whether or not the Element is the\n     *                            Document Body Element\n     */\n\n\n    isDocumentBody(element) {\n      return element.tagName.toUpperCase() === 'BODY';\n    }\n\n  };\n\n  ScrollToService.ɵfac = function ScrollToService_Factory(t) {\n    return new (t || ScrollToService)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(PLATFORM_ID));\n  };\n\n  ScrollToService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ScrollToService,\n    factory: function (t) {\n      return ScrollToService.ɵfac(t);\n    }\n  });\n  ScrollToService = __decorate([__param(0, Inject(DOCUMENT)), __param(1, Inject(PLATFORM_ID))], ScrollToService);\n  return ScrollToService;\n})();\nlet ScrollToDirective = /*#__PURE__*/(() => {\n  let ScrollToDirective = class ScrollToDirective {\n    constructor(elementRef, scrollToService, renderer2) {\n      this.elementRef = elementRef;\n      this.scrollToService = scrollToService;\n      this.renderer2 = renderer2;\n      this.ngxScrollTo = DEFAULTS.target;\n      this.ngxScrollToEvent = DEFAULTS.action;\n      this.ngxScrollToDuration = DEFAULTS.duration;\n      this.ngxScrollToEasing = DEFAULTS.easing;\n      this.ngxScrollToOffset = DEFAULTS.offset;\n      this.ngxScrollToOffsetMap = DEFAULTS.offsetMap;\n    }\n    /**\n     * Angular Lifecycle Hook - After View Init\n     *\n     * @todo Implement Subscription for Events\n     *\n     * @returns void\n     */\n\n\n    ngAfterViewInit() {\n      // Test Event Support\n      if (EVENTS.indexOf(this.ngxScrollToEvent) === -1) {\n        throw new Error(`Unsupported Event '${this.ngxScrollToEvent}'`);\n      } // Listen for the trigger...\n\n\n      this.renderer2.listen(this.elementRef.nativeElement, this.ngxScrollToEvent, event => {\n        this.options = {\n          target: this.ngxScrollTo,\n          duration: this.ngxScrollToDuration,\n          easing: this.ngxScrollToEasing,\n          offset: this.ngxScrollToOffset,\n          offsetMap: this.ngxScrollToOffsetMap\n        };\n        this.scrollToService.scrollTo(this.options);\n      });\n    }\n\n  };\n\n  ScrollToDirective.ɵfac = function ScrollToDirective_Factory(t) {\n    return new (t || ScrollToDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ScrollToService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  ScrollToDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ScrollToDirective,\n    selectors: [[\"\", \"ngxScrollTo\", \"\"]],\n    inputs: {\n      ngxScrollTo: \"ngxScrollTo\",\n      ngxScrollToEvent: \"ngxScrollToEvent\",\n      ngxScrollToDuration: \"ngxScrollToDuration\",\n      ngxScrollToEasing: \"ngxScrollToEasing\",\n      ngxScrollToOffset: \"ngxScrollToOffset\",\n      ngxScrollToOffsetMap: \"ngxScrollToOffsetMap\"\n    }\n  });\n\n  __decorate([Input()], ScrollToDirective.prototype, \"ngxScrollTo\", void 0);\n\n  __decorate([Input()], ScrollToDirective.prototype, \"ngxScrollToEvent\", void 0);\n\n  __decorate([Input()], ScrollToDirective.prototype, \"ngxScrollToDuration\", void 0);\n\n  __decorate([Input()], ScrollToDirective.prototype, \"ngxScrollToEasing\", void 0);\n\n  __decorate([Input()], ScrollToDirective.prototype, \"ngxScrollToOffset\", void 0);\n\n  __decorate([Input()], ScrollToDirective.prototype, \"ngxScrollToOffsetMap\", void 0);\n\n  return ScrollToDirective;\n})();\nvar ScrollToModule_1;\n/** Scroll To Module */\n\nlet ScrollToModule = ScrollToModule_1 = class ScrollToModule {\n  /**\n   * Guaranteed singletons for provided Services across App.\n   *\n   * @return          An Angular Module with Providers\n   */\n  static forRoot() {\n    return {\n      ngModule: ScrollToModule_1,\n      providers: [ScrollToService]\n    };\n  }\n\n};\n\nScrollToModule.ɵfac = function ScrollToModule_Factory(t) {\n  return new (t || ScrollToModule)();\n};\n\nScrollToModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: ScrollToModule\n});\nScrollToModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ScrollToModule, {\n    declarations: [ScrollToDirective],\n    exports: [ScrollToDirective]\n  });\n})();\n/*\n * Public API Surface of ngx-scroll-to\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ScrollToDirective, ScrollToModule, ScrollToService }; //# sourceMappingURL=nicky-lenaers-ngx-scroll-to.js.map","map":null,"metadata":{},"sourceType":"module"}